{"ast":null,"code":"import api from './api';\n\n// Store view tracking data in sessionStorage to prevent duplicate tracking\nconst TRACKED_VIDEOS_KEY = 'tracked_videos';\n\n/**\r\n * Track video view count by sending a request to the backend\r\n * @param {number} videoId - The ID of the video to track\r\n * @param {Object} options - Additional tracking options\r\n * @param {number} options.watchDuration - Watch duration in seconds\r\n * @param {boolean} options.isCompleted - Whether the video was watched to completion\r\n * @returns {Promise} - Promise that resolves when the view is tracked\r\n */\nexport const trackVideoView = async (videoId, options = {}) => {\n  try {\n    // Check if we've already tracked this video in this session\n    const trackedVideos = JSON.parse(sessionStorage.getItem(TRACKED_VIDEOS_KEY) || '{}');\n\n    // If we've already tracked this video and it was completed, don't track again\n    if (trackedVideos[videoId] && trackedVideos[videoId].isCompleted) {\n      console.log(`Video ${videoId} already tracked as completed, skipping`);\n      return null;\n    }\n\n    // Mark as tracked in sessionStorage\n    trackedVideos[videoId] = {\n      timestamp: Date.now(),\n      isCompleted: options.isCompleted || false\n    };\n    sessionStorage.setItem(TRACKED_VIDEOS_KEY, JSON.stringify(trackedVideos));\n\n    // Send request to track video view\n    const response = await api.post('/api/videos/track-view/', {\n      video_id: videoId,\n      watch_duration: options.watchDuration || 0,\n      is_completed: options.isCompleted || false\n    });\n    console.log(`Video view tracked for video ID: ${videoId}`, response.data);\n    return response.data;\n  } catch (error) {\n    console.error(`Error tracking video view for video ID: ${videoId}`, error);\n    // We don't want to interrupt the user experience if tracking fails\n    // So we just log the error and continue\n    return null;\n  }\n};\n\n/**\r\n * Format view count for display (e.g., 1.2K, 3.4M)\r\n * @param {number} views - The number of views\r\n * @returns {string} - Formatted view count\r\n */\nexport const formatViewCount = views => {\n  if (views >= 1000000) {\n    return `${(views / 1000000).toFixed(1)}M`;\n  } else if (views >= 1000) {\n    return `${(views / 1000).toFixed(1)}K`;\n  }\n  return views.toString();\n};\n\n/**\r\n * Track video completion (watched to the end)\r\n * @param {number} videoId - The ID of the video\r\n * @returns {Promise} - Promise that resolves when completion is tracked\r\n */\nexport const trackVideoCompletion = async videoId => {\n  return trackVideoView(videoId, {\n    isCompleted: true\n  });\n};\nexport default {\n  trackVideoView,\n  trackVideoCompletion,\n  formatViewCount\n};","map":{"version":3,"names":["api","TRACKED_VIDEOS_KEY","trackVideoView","videoId","options","trackedVideos","JSON","parse","sessionStorage","getItem","isCompleted","console","log","timestamp","Date","now","setItem","stringify","response","post","video_id","watch_duration","watchDuration","is_completed","data","error","formatViewCount","views","toFixed","toString","trackVideoCompletion"],"sources":["D:/OTT/ott_frontend/src/utils/videoTracking.js"],"sourcesContent":["import api from './api';\r\n\r\n// Store view tracking data in sessionStorage to prevent duplicate tracking\r\nconst TRACKED_VIDEOS_KEY = 'tracked_videos';\r\n\r\n/**\r\n * Track video view count by sending a request to the backend\r\n * @param {number} videoId - The ID of the video to track\r\n * @param {Object} options - Additional tracking options\r\n * @param {number} options.watchDuration - Watch duration in seconds\r\n * @param {boolean} options.isCompleted - Whether the video was watched to completion\r\n * @returns {Promise} - Promise that resolves when the view is tracked\r\n */\r\nexport const trackVideoView = async (videoId, options = {}) => {\r\n  try {\r\n    // Check if we've already tracked this video in this session\r\n    const trackedVideos = JSON.parse(sessionStorage.getItem(TRACKED_VIDEOS_KEY) || '{}');\r\n    \r\n    // If we've already tracked this video and it was completed, don't track again\r\n    if (trackedVideos[videoId] && trackedVideos[videoId].isCompleted) {\r\n      console.log(`Video ${videoId} already tracked as completed, skipping`);\r\n      return null;\r\n    }\r\n    \r\n    // Mark as tracked in sessionStorage\r\n    trackedVideos[videoId] = {\r\n      timestamp: Date.now(),\r\n      isCompleted: options.isCompleted || false\r\n    };\r\n    sessionStorage.setItem(TRACKED_VIDEOS_KEY, JSON.stringify(trackedVideos));\r\n    \r\n    // Send request to track video view\r\n    const response = await api.post('/api/videos/track-view/', {\r\n      video_id: videoId,\r\n      watch_duration: options.watchDuration || 0,\r\n      is_completed: options.isCompleted || false\r\n    });\r\n    \r\n    console.log(`Video view tracked for video ID: ${videoId}`, response.data);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error(`Error tracking video view for video ID: ${videoId}`, error);\r\n    // We don't want to interrupt the user experience if tracking fails\r\n    // So we just log the error and continue\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Format view count for display (e.g., 1.2K, 3.4M)\r\n * @param {number} views - The number of views\r\n * @returns {string} - Formatted view count\r\n */\r\nexport const formatViewCount = (views) => {\r\n  if (views >= 1000000) {\r\n    return `${(views / 1000000).toFixed(1)}M`;\r\n  } else if (views >= 1000) {\r\n    return `${(views / 1000).toFixed(1)}K`;\r\n  }\r\n  return views.toString();\r\n};\r\n\r\n/**\r\n * Track video completion (watched to the end)\r\n * @param {number} videoId - The ID of the video\r\n * @returns {Promise} - Promise that resolves when completion is tracked\r\n */\r\nexport const trackVideoCompletion = async (videoId) => {\r\n  return trackVideoView(videoId, { isCompleted: true });\r\n};\r\n\r\nexport default {\r\n  trackVideoView,\r\n  trackVideoCompletion,\r\n  formatViewCount\r\n};"],"mappings":"AAAA,OAAOA,GAAG,MAAM,OAAO;;AAEvB;AACA,MAAMC,kBAAkB,GAAG,gBAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAG,MAAAA,CAAOC,OAAO,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAK;EAC7D,IAAI;IACF;IACA,MAAMC,aAAa,GAAGC,IAAI,CAACC,KAAK,CAACC,cAAc,CAACC,OAAO,CAACR,kBAAkB,CAAC,IAAI,IAAI,CAAC;;IAEpF;IACA,IAAII,aAAa,CAACF,OAAO,CAAC,IAAIE,aAAa,CAACF,OAAO,CAAC,CAACO,WAAW,EAAE;MAChEC,OAAO,CAACC,GAAG,CAAC,SAAST,OAAO,yCAAyC,CAAC;MACtE,OAAO,IAAI;IACb;;IAEA;IACAE,aAAa,CAACF,OAAO,CAAC,GAAG;MACvBU,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;MACrBL,WAAW,EAAEN,OAAO,CAACM,WAAW,IAAI;IACtC,CAAC;IACDF,cAAc,CAACQ,OAAO,CAACf,kBAAkB,EAAEK,IAAI,CAACW,SAAS,CAACZ,aAAa,CAAC,CAAC;;IAEzE;IACA,MAAMa,QAAQ,GAAG,MAAMlB,GAAG,CAACmB,IAAI,CAAC,yBAAyB,EAAE;MACzDC,QAAQ,EAAEjB,OAAO;MACjBkB,cAAc,EAAEjB,OAAO,CAACkB,aAAa,IAAI,CAAC;MAC1CC,YAAY,EAAEnB,OAAO,CAACM,WAAW,IAAI;IACvC,CAAC,CAAC;IAEFC,OAAO,CAACC,GAAG,CAAC,oCAAoCT,OAAO,EAAE,EAAEe,QAAQ,CAACM,IAAI,CAAC;IACzE,OAAON,QAAQ,CAACM,IAAI;EACtB,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdd,OAAO,CAACc,KAAK,CAAC,2CAA2CtB,OAAO,EAAE,EAAEsB,KAAK,CAAC;IAC1E;IACA;IACA,OAAO,IAAI;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAIC,KAAK,IAAK;EACxC,IAAIA,KAAK,IAAI,OAAO,EAAE;IACpB,OAAO,GAAG,CAACA,KAAK,GAAG,OAAO,EAAEC,OAAO,CAAC,CAAC,CAAC,GAAG;EAC3C,CAAC,MAAM,IAAID,KAAK,IAAI,IAAI,EAAE;IACxB,OAAO,GAAG,CAACA,KAAK,GAAG,IAAI,EAAEC,OAAO,CAAC,CAAC,CAAC,GAAG;EACxC;EACA,OAAOD,KAAK,CAACE,QAAQ,CAAC,CAAC;AACzB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,oBAAoB,GAAG,MAAO3B,OAAO,IAAK;EACrD,OAAOD,cAAc,CAACC,OAAO,EAAE;IAAEO,WAAW,EAAE;EAAK,CAAC,CAAC;AACvD,CAAC;AAED,eAAe;EACbR,cAAc;EACd4B,oBAAoB;EACpBJ;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}